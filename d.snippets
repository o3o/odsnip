# ------------------
# Language
# ------------------
priority -50

snippet vd "void (vd)" w
void 
endsnippet

snippet len "length (len)" i
length
endsnippet

snippet over "override (over)" b
override ${1:/*function*/}
endsnippet

snippet al "alias (al)" b
alias ${1:/+1: alias+/} = ${2:/+2: original name+/};
${0}
endsnippet

snippet mixin "mixin (mixin)" b
mixin ${1:/*mixed_in*/} ${2:/*name*/};
endsnippet

snippet new "new (new)" w
new ${1}(${2});
endsnippet

snippet scpn "@safe const pure nothrow (scpn)"
@safe const pure nothrow
endsnippet

snippet spn "@safe pure nothrow (spn)"
@safe pure nothrow
endsnippet

snippet cont "continue (cont)" b
continue;
endsnippet

snippet dis "@disable (dis)" b
@disable ${1:/*method*/};
endsnippet

snippet pub "public (pub)" b
public 
endsnippet

snippet publ "public: (publ)" b
public:
	${1:/*members*/}
endsnippet

snippet pubb "public { (publ) }" b
public {
	${1:/*members*/}
}
endsnippet

snippet priv "private (priv)" b
private 
endsnippet

snippet privl "private (priv)" b
private:
	${1:/*members*/}
endsnippet

snippet protl "protected (prot)" b
protected:
	${1:/*members*/}
endsnippet

snippet pack "package (pack)" b
package 
endsnippet

snippet packl "package (pack)" b
package:
	${1:/*members*/}
endsnippet

snippet ret "return (ret)" w
return 
endsnippet

snippet rett "return value(rett)" b
return ${1:/*value to return*/};
endsnippet

snippet auto "auto (auto)" b
auto ${1:/*variable*/} = ${2:/*value*/};
endsnippet

snippet con "const (con)" b
const ${1:/*variable*/} = ${2:/*value*/};
endsnippet

snippet const "const()" i
const(${1:${VISUAL}})
endsnippet

snippet siz "size_t (siz)" b
size_t ${1:/*variable*/} = ${2:/*value*/};
endsnippet

snippet sup "super (sup)" b
super(${1:/*args*/});
endsnippet

snippet format "format (format)" w
"${1:/*format string*/}".format(${0:/*values*/})
endsnippet

snippet module "New module (module)" b
module ${1:/*name*/}

${0}
endsnippet

snippet with "with (with)"
with (${1}) {
	${VISUAL}${2:/*code*/}
}
endsnippet

snippet scope "scope (scope)" b
scope (${1:exit}) {
	${VISUAL}${2:/*code*/}
}
endsnippet

snippet cast "cast()" 
cast(${1:/*type*/})
endsnippet

# ------------------
# vibe.d log
# ------------------
snippet logd "logDebug (logd)" b
logDebug("${1:/*msg*/}");
endsnippet

snippet logdi "logDiagnostic (logdi)" b
logDiagnostic("${1:/*msg"/}");
endsnippet

snippet logi "logInfo (logi)" b
logInfo("${1:/*msg*/}");
endsnippet

snippet logw "logWarn (logw)" b
logWarn("${1:/*msg"/}");
endsnippet

snippet loge "logError (loge)" b
logError("${1:/*msg*/}");
endsnippet

# ------------------
# Phobos experimental log
# ------------------
snippet lt "trace (lt)" b
trace("${1:/*msg*/}");
endsnippet
snippet ltf "trace format (ltf)" b
tracef("${1:/*msg*/}", ${2:/*arg*/});
endsnippet

snippet li "info (li)" b
info("${1:/*msg*/}");
endsnippet
snippet lif "info format (lif)" b
infof("${1:/*msg*/}", ${2:/*arg*/});
endsnippet

snippet lw "warning (lw)" b
warning("${1:/*msg*/}");
endsnippet
snippet lwf "warning format (lwf)" b
warningf("${1:/*msg*/}", ${2:/*arg*/});
endsnippet

snippet le "error (le)" b
error("${1:/*msg*/}");
endsnippet
snippet lef "error format (lef)" b
errorf("${1:/*msg*/}", ${2:/*arg*/});
endsnippet

snippet lc "critical (lc)" b
critical("${1:/*msg*/}");
endsnippet
snippet lcf "critical format (lcf)" b
criticalf("${1:/*msg*/}", ${2:/*arg*/});
endsnippet

# ------------------
# import
# ------------------
snippet impo "import (impo)" b
import ${1:/*module*/};
endsnippet

snippet pimp "public import (pimp)" b
public import ${1:/*module*/};
endsnippet

snippet impa "import std.array (impa)" b
import std.array;
endsnippet

snippet impc "import std.conv (impc)" b
import std.conv;
endsnippet

snippet impe "import std.signals (impe)" b
import std.signals;
endsnippet

snippet impex "import std.exception (impex)" b
import std.exception;
endsnippet

snippet impf "import std.file (imp)" b
import std.file;
endsnippet

snippet impi "import std.stdio (impi)" b
import std.stdio;
endsnippet

snippet imps "import std.string (imps)" b
import std.string;
endsnippet

snippet impu "import unit_threaded (impu)" b
import unit_threaded;
endsnippet

snippet impuv "version import unit_threaded (impuv)" b
version (unittest) {
   import unit_threaded;
}
endsnippet

snippet impl "import std.experimental.logger (impl)" b
import std.experimental.logger;
endsnippet


snippet imp "import std.system (imp)" b
import std.system;
endsnippet

snippet imp "import std.bitmanip (imp)" b
import std.bitmanip;
endsnippet

snippet imp "import unit_threaded.runner (imp)" b
import unit_threaded.runner;
endsnippet


snippet imp "import std.contracts (imp)" b
import std.contracts;
endsnippet

snippet imp "import std.path (imp)" b
import std.path;
endsnippet

snippet imp "import std.datetime (imp)" b
import std.datetime;
endsnippet


# ------------------
# unit_thread
# ------------------
snippet seq "shouldEqual (seq)" w
shouldEqual(${1:/*to*/});
endsnippet

snippet saeq "shouldApproxEqual (seq)" w
shouldApproxEqual(${1:/*to*/});
endsnippet

snippet sinc "shouldInclude (sinc)" w
shouldInclude(${1:/*item*/});
endsnippet

snippet sneq "shouldNotEqual (sneq)" w
shouldNotEqual(${1:/*to*/});
endsnippet

snippet st "shouldBeTrue (st)" w
shouldBeTrue;
endsnippet

snippet sf "shouldBeFalse (sf)" w
shouldBeFalse;
endsnippet

snippet sn "shouldBeNull (sn)" w
shouldBeNull;
endsnippet

snippet snn "shouldNotBeNull (snn)" w
shouldNotBeNull;
endsnippet

snippet sth "shouldThrow (sth)" w
shouldThrow!${1:Exception};
endsnippet

snippet sgt "shouldBeGreaterThan (sgh)" w
shouldBeGreaterThan(${1:/*to*/});
endsnippet

snippet sst "shouldBeSmallerThan (sst)" w
shouldBeSmallerThan(${1:/*to*/});
endsnippet

snippet ssj "shouldBeSameJsonAs (ssh)" w
shouldBeSameJsonAs(${1:/*to*/});
endsnippet

snippet snth "shouldNotThrow (snth)" w
shouldNotThrow!${1:Exception};
endsnippet

snippet ht "HiddenTest (ht)" b
@HiddenTest(${1:message})
endsnippet

snippet ut "UnitTest (ht)" b
@UnitTest
endsnippet

# ------------------
# Phobos
# ------------------
snippet imm "immutable()" i
immutable(${1:${VISUAL}})
endsnippet

snippet tup "tuple (tup)"
tuple(${1:/*first*/}, ${0:/*more*/})
endsnippet

snippet wr "writeln (wr)"
writeln(${1:${VISUAL}});
${0}
endsnippet

snippet wrf "writefln (wrf)" b
writefln("${1:/+1: format string+/}", ${2:${VISUAL}});
${0}
endsnippet

# ------------------
# Conversion
# ------------------
snippet to "to!T()" w
to!${1:/*type*/}(${2:/*arg*/})
endsnippet

snippet top "to!(T)()" w
to!(${1:/*type*/})(${2:/*arg*/})
endsnippet

snippet tos "to!string()" w
to!string()$1
endsnippet

snippet tosa "to!string(arg)" w
to!string(${1:/*arg*/})
endsnippet


# ------------------
# Branches
# ------------------
snippet if "if ()" b
if (${1:/*condition*/}) {
	${VISUAL}${2:/*code*/}
}
${3}
endsnippet

snippet ifn "if null.. (ifn)" b
if (${1:/*condition*/} is null) {
	${VISUAL}${0:/*code*/}
}
endsnippet

snippet ifnn "if not null.. (ifnn)" b
if (${1:/*condition*/} !is null) {
	${VISUAL}${0:/*code*/}
}
endsnippet

snippet ife "if .. else (ife)" b
if (${1:/*condition*/}) {
	${2:/*code*/}
} else {
	${3:/*else*/}
}
endsnippet

snippet el "else (el)" w
else {
	${VISUAL}${1:/*code*/}
}
endsnippet

snippet elif "else if (elif)" w
else if (${1:/*condition*/}) {
	${VISUAL}${0:/*code*/}
}
endsnippet

snippet sif "static if (sif)" w
static if (${1:/*condition*/}) {
	${VISUAL}${2:/*code*/}
}
${3}
endsnippet

snippet sw "switch (sw)" b
switch (${1:/*var*/}) {
	case ${2:/*value*/}:
		${3:/*code*/}
		break;
	case ${4:/*value*/}:
		${5:/*code*/}
		break;
	${7:/*more cases*/}
	default:
		${6:assert(false);}
}
endsnippet

snippet fsw "final switch (fsw)" b
final switch (${1:/*var*/}) {
	case ${2:/*value*/}:
		${3:/*code*/}
		break;
	case ${4:/*value*/}:
		${5:/*code*/}
		break;
	${7:/*more cases*/}
}
endsnippet

snippet case "case (case)" b
case ${1:/*value*/}:
	${2:/*code*/}
	break;
endsnippet

snippet ?: "ternary operator (?:)" i
${1:/*condition*/} ? ${2:/*then*/} : ${3:/*else*/}$4
endsnippet

# ------------------
# Loops
# ------------------
snippet do "do while (do)" b
do {
	${VISUAL}${2:/*code*/}
} while (${1:/*condition*/});
endsnippet

snippet wh "while (wh)" b
while (${1:/*condition*/}) {
	${VISUAL}${2:/*code*/}
}
endsnippet

snippet for "for (for)" b
for (${4:size_t} ${2:i} = 0; $2 < ${1:count}; ${3:++$2}) {
	${VISUAL}${0:/*code*/}
}
endsnippet

snippet fori "for (int i...) (fori)" b
for (int i = 0; i < ${1:count}; ++i) {
	${VISUAL}${0:/*code*/}
}
endsnippet

snippet forever "forever (forever)" b
for (;;) {
	${VISUAL}${0:/*code*/}
}
endsnippet

snippet fore "foreach (fore)" b
foreach (${1:/*elem*/}; ${2:/*range*/}) {
	${VISUAL}${0:/*code*/}
}
endsnippet

snippet forei "foreach 0 .. N (forei)" b
foreach (i; 0 .. ${1:/*max*/}) {
	${VISUAL}${0:/*code*/}
}
endsnippet

snippet forif "foreach if (forif)" b
foreach (${1:/*elem*/}; ${2:/*range*/}) if(${3:/*condition*/}) {
	${VISUAL}${4:/*code*/}
}
endsnippet

# ------------------
# Contracts
# ------------------
snippet req "assert non null and assign" b
assert(${1:var} !is null);
this.$1 = $1;
endsnippet

snippet in "in contract (in)" b
in {
	assert(${1:/*condition*/}, "${2:error message}");
	${3}
endsnippet

snippet out "out contract (out)" b
} out ${1:(result) {
	assert(${2:/*condition*/}, "${3:error message}");
	${4}
endsnippet

snippet body "body contract (body)" b
} do {
   ${1}
}
endsnippet

snippet inv "invariant (inv)" b
invariant() {
	assert(${1:/*condition*/}, "${2:error message}");
	${3}
}
endsnippet

snippet enf "enforce without exception (enf)" b
enforce(${1:/*condition*/});
endsnippet

snippet enfe "enforce with exception (enfe)" b
enforce(${1:/*condition*/},
	new ${2}Exception(${3:/*args*/}));
endsnippet

snippet enfa "enforce with assegnation (enfa)" b
enforce(${1:/*condition*/} !is null);
this.$1 = $1;
endsnippet

# ------------------
# Functions 
# ------------------
snippet fun "function definition (fun)" b
${1:void} ${2:/*function name*/}(${3:/*args*/}) ${4:@safe pure nothrow} {
	${VISUAL}${5:/*code*/}
}
endsnippet

snippet func "void function definition (void)" b
void ${1:/*function name*/}(${2:/*args*/}) ${3:@safe pure nothrow} {
	${VISUAL}${4:/*code*/}
}
endsnippet

snippet bar "function definition (bar)" b
${1:void} ${2:/*function name*/}(${3:/*args*/}) {
	${VISUAL}${5:/*code*/}
}
endsnippet

snippet this "ctor (this)" w
this(${1:/*args*/}) {
	${VISUAL}${2:/*code*/}
}
endsnippet

snippet get "getter property (get)"
private ${1:/*type*/} _${2:/*member_name*/};
$1 $2() { return _$2; }
endsnippet

snippet set "setter property (set)"
void ${1:/*member_name*/}(${2:/*type*/} value) { ${3:_$1} = value; }
endsnippet

snippet getset "getter/setter property"
private ${1:/*type*/} _${2:/*member_name*/};
$1 $2() { return _$2; }
void $2($1 value) { _$2 = value; }
endsnippet

snippet getp "getter property (get) pure"
${1:/*type*/} ${2:/*member_name*/}() const pure nothrow {return ${3:_$2};}
endsnippet

snippet setp "setter property (set) pure"
void ${1:/*member_name*/}(${2:/*type*/} value) pure nothrow {${3:_$1} = value;}
endsnippet

snippet getsetp "getter/setter property pure"
private ${1:/*type*/} _${2:/*member_name*/};
$1 $2() const pure nothrow { return _$2; }
void $2($1 value) pure nothrow { _$2 = value; }
endsnippet

snippet main " void main" b
void main(string[] args) {
	${VISUAL}${0: /*code*/}
}
endsnippet

snippet maini "int main" b
int main(string[] args) {
	${VISUAL}${0: /*code*/}
	return 0;
}
endsnippet

# ------------------
# Signal
# ------------------
snippet signal "signal (signal)" b
mixin Signal!(${1:/*args*/}) ${2:/*name*/};
endsnippet

snippet emit "emit" w
emit(${1:/*arg*/});
endsnippet


# ------------------
# Exception handling
# ------------------
snippet try "try/catch (try)" b
try {
	${VISUAL}${1:/*code to try*/}
} catch (${2}Exception e) {
	${3:/*handle exception*/}
}
endsnippet

snippet tryf "try/catch/finally (tryf)" b
try {
	${VISUAL}${1:/*code to try*/}
} catch (${2}Exception e) {
	${3:/*handle exception*/}
} finally {
	${4:/*cleanup*/}
}
endsnippet

snippet catch "catch (catch)" w
catch (${1}Exception e) {
	${2:/*handle exception*/}
}
endsnippet

snippet thr "throw (thr)" w
throw new ${1}Exception("${2}");
endsnippet

snippet exc "exception declaration (exc)" b
class ${1}Exception: ${2}Exception {
	public this(string msg, string file = __FILE__, int line = __LINE__) {
		super(msg, file, line);
	}
}
endsnippet

# ----------------
# Type definitions
# ----------------
snippet struct "struct (struct)"
struct ${1:name} {
	${0}
}
endsnippet

snippet union "union (union)"
union ${1:name} {
	${0}
}
endsnippet

snippet class "class (class)" b
class ${1:name} {
	${0}
}
endsnippet

snippet inter "interface (inter)" b
interface ${1:name} {
	${0}
}
endsnippet

snippet enum "enum (enum)" b
enum ${1:name} {
	${0}
}
endsnippet

# ------------------
# Conditional compilation
# ------------------
snippet version "version (version)" b
version (${1:/*version name*/}) {
	${VISUAL}${2:/*code*/}
}
endsnippet

snippet versioni "inline version (version)" b
version (${1:/*name*/}) ${2:/*code*/}
endsnippet

snippet versionl "version (linux)" b
version (linux) {
	${VISUAL}${2:/*code*/}
}
endsnippet

snippet versionw "version (Windows)" b
version (Windows) {
	${VISUAL}${2:/*code*/}
}
endsnippet

snippet versionil "inline version (linux)" b
version (linux) ${1:/*code*/}
endsnippet

snippet versioniw "inline version (Windows)" b
version (Windows) ${1:/*code*/}
endsnippet

snippet debug "debug" b
debug {
	${VISUAL}${1:/*code*/}
}
endsnippet

# ------------------
# Templates
# ------------------
snippet temp "template (temp)" b
template ${2:/*name*/}(${1:/*args*/}) {
	${3:/*code*/}
}
endsnippet

# ------------------
# Asserts
# ------------------
snippet as "assert (as)" b
assert(${1:false});
endsnippet

snippet asm "assert with message (asm)" b
assert(${1:/*condition*/}, "${2:error message}");
endsnippet

snippet sas "static assert (sass)" b
static assert(${1:false});
endsnippet

snippet asn "assert non null" b
assert(${1:var} !is null);
endsnippet


# ------------------
# Unittests
# ------------------
snippet unittest "unittest (unittest)" b
unittest {
	${1:/*code*/}
}
endsnippet

# ------------------
# Common member functions
# ------------------
snippet opDis "opDispatch (opDis)" b
${1:/*return type*/} opDispatch(string s)() {
	${2:/*code*/};
}
endsnippet

snippet op= "opAssign (op=)" b
void opAssign(${1} rhs) ${2:@safe pure nothrow} {
	${2:/*code*/}
}
endsnippet

snippet opCmp "opCmp (opCmp)" b
int opCmp(${1} rhs) @safe const pure nothrow {
	${2:/*code*/}
}
endsnippet

snippet opApply "opApply (opApply)" b
int opApply(int delegate(ref ${1:/*iterated type/s*/}) dg) {
	int result = 0;
	${2:/*loop*/}
	{
		result = dg(${3:/*arg/s*/});
		if(result){break;}
	}
	return result;
}
endsnippet

snippet toString "toString (toString)" b
string toString() @safe const pure nothrow {
	${1:/*code*/}
}
endsnippet

# ------------------
# DDoc and comments
# ------------------
snippet fix "fix (todo)" b
// FIX: ${1}
endsnippet

snippet todo "TODO (todo)" b
// TODO: ${1}
endsnippet

snippet sdoc "short ddoc block (sdoc)" b
/**
 * ${1:description}
 */
endsnippet

snippet doc "generic ddoc block (doc)" b
/**
 * ${1:description}
 *
 * ${2:details}
 */
endsnippet

snippet fdoc "function ddoc block (fdoc)" b
/**
 * ${1:description}
 *
 * ${2:Params:
 *  ${3:param} = ${4:param description} ${5}}
 *  
 * ${6:Returns: ${7:return value}}
 *
 * ${8:Throws:  ${9}Exception ${10}}
*/
endsnippet

snippet fsdoc "short function ddoc block (fsdoc)" b
/**
 * ${1:description}
 *
 * ${2:Params:
 *  ${3:param} = ${4:param description} ${5}}
 */
endsnippet

snippet Pars "Params (Pars)"
Params:
*  ${1:param} = ${2:param description}
*  ${3}
endsnippet

snippet Par "Params (Par)"
${1:param} = ${2:param description}
endsnippet

snippet Ret "Returns (Ret)"
Returns:  ${1:return value/s}
endsnippet

snippet Thr "Throws (Thr)"
Throws:  ${1}Exception ${2}
endsnippet

snippet Example "Examples (Example)"
Examples:
* --------------------
* ${1:example code}
* --------------------
endsnippet

snippet don "dfmt on (don)" b
// dfmt on
endsnippet

snippet doff "dfmt off (doff)" b
// dfmt off
endsnippet

# ------------------
# License 
# ------------------

snippet gpl "GPL (gpl)" b
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 2 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
//
// Copyright (C) ${1:Author}, `!v strftime("%Y")`

${2}
endsnippet

snippet boost "Boost (boost)" b
//          Copyright ${1:Author} `!v strftime("%Y")`.
// Distributed under the Boost Software License, Version 1.0.
//    (See accompanying file LICENSE_1_0.txt or copy at
//          http://www.boost.org/LICENSE_1_0.txt)

${2}
endsnippet
